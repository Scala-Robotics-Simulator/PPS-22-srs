"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1885],{4335:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>t,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"implementation/simone-ceredi/configuration","title":"Configurazione","description":"Come descritto nella sezione di design di dettaglio dedicata, la gestione della configurazione \xe8 stata implementata sfruttando il pattern Tagless Final.","source":"@site/docs/05-implementation/02-simone-ceredi/4-configuration.md","sourceDirName":"05-implementation/02-simone-ceredi","slug":"/implementation/simone-ceredi/configuration","permalink":"/PPS-22-srs/docs/implementation/simone-ceredi/configuration","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4},"sidebar":"docsSidebar","previous":{"title":"Sensori","permalink":"/PPS-22-srs/docs/implementation/simone-ceredi/sensors"},"next":{"title":"Implementazione della GUI di configurazione","permalink":"/PPS-22-srs/docs/implementation/simone-ceredi/config-gui"}}');var a=n(4848),r=n(8453);const t={sidebar_position:4},s="Configurazione",l={},d=[{value:"YAML",id:"yaml",level:2},{value:"Struttura",id:"struttura",level:3},{value:"Parsing della configurazione",id:"parsing-della-configurazione",level:2},{value:"Serializzazione della configurazione",id:"serializzazione-della-configurazione",level:2}];function c(e){const i={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"configurazione",children:"Configurazione"})}),"\n",(0,a.jsxs)(i.p,{children:["Come descritto nella sezione di ",(0,a.jsx)(i.a,{href:"/PPS-22-srs/docs/detailed-design/configuration",children:"design di dettaglio"})," dedicata, la gestione della configurazione \xe8 stata implementata sfruttando il pattern ",(0,a.jsx)(i.strong,{children:"Tagless Final"}),".\nPer la gestione della configurazione \xe8 stato creato il trait ",(0,a.jsx)(i.code,{children:"ConfigManager"})," che definisce i metodi per il caricamento e il salvataggio della configurazione."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"trait ConfigManager[F[_]]:\n  def load: F[ConfigResult[SimulationConfig[Environment]]]\n  def save(config: SimulationConfig[Environment]): F[Unit]\n"})}),"\n",(0,a.jsxs)(i.p,{children:["Questa implementazione consente di gestire in modo flessibile la configurazione del simulatore, grazie alla definizione di ",(0,a.jsx)(i.em,{children:"interpreti"})," multipli dell'",(0,a.jsx)(i.em,{children:"algebra"})," di configurazione (ad esempio ",(0,a.jsx)(i.code,{children:"YamlConfigManager"})," per la gestione della configurazione in formato ",(0,a.jsx)(i.em,{children:"YAML"}),")."]}),"\n",(0,a.jsx)(i.h2,{id:"yaml",children:"YAML"}),"\n",(0,a.jsx)(i.h3,{id:"struttura",children:"Struttura"}),"\n",(0,a.jsxs)(i.p,{children:["Dato che la configurazione del simulatore risulterebbe molto complessa se trasformata in un singolo file ",(0,a.jsx)(i.em,{children:"YAML"}),", la struttura \xe8 stata semplificata introducendo parametri che fungono da scorciatoie per configurare diverse porzioni del simulatore in modo pi\xf9 intuitivo."]}),"\n",(0,a.jsx)(i.p,{children:"Nel caso dei robot, ad esempio, invece che specificare ogni sensore disponibile al robot, \xe8 possibile utilizzare un parametro che indica se il robot dispone dei sensori di prossimit\xe0 o di luce standard (8 sensori per tipo, orientati a 45 gradi l'uno dall'altro)."}),"\n",(0,a.jsx)(i.p,{children:"Anche per la gestione degli attuatori \xe8 possibile specificare la velocit\xe0 di movimento del robot, invece di dover configurare ogni singolo attuatore."}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-yaml",children:"- robot:\n    position: [3, 1]\n    orientation: 90.0\n    radius: 0.5\n    speed: 1.0\n    withProximitySensors: true\n    withLightSensors: true\n    behavior: CollisionAvoidance\n"})}),"\n",(0,a.jsx)(i.h2,{id:"parsing-della-configurazione",children:"Parsing della configurazione"}),"\n",(0,a.jsxs)(i.p,{children:["Per il parsing della configurazione ",(0,a.jsx)(i.em,{children:"YAML"})," \xe8 stata utilizzata la libreria ",(0,a.jsx)(i.a,{href:"https://github.com/VirtusLab/scala-yaml",children:"scala-yaml"}),", che permette di effettuare il parsing di un file ",(0,a.jsx)(i.em,{children:"YAML"})," trattandolo come una ",(0,a.jsx)(i.code,{children:"Map[String, Any]"}),". Questo approccio consente di gestire in modo flessibile la configurazione, permettendo di utilizzare parametri di alto livello per configurare il simulatore senza dover specificare ogni dettaglio."]}),"\n",(0,a.jsxs)(i.p,{children:["Il codice sotto mostra come viene effettuato il parsing della configurazione ",(0,a.jsx)(i.em,{children:"YAML"})," per un robot, estraendo i vari parametri dalla mappa e creando un'istanza di ",(0,a.jsx)(i.code,{children:"Robot"})," con le opzioni specificate."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"  private def parseRobot(map: Map[String, Any]): ConfigResult[Entity] =\n    for\n      id <- getOptional[UUID](EntityFields.Id, map)\n      pos <- get[List[Double]](EntityFields.Position, map)\n      position <- parsePosition(pos)\n      orient <- getOptional[Double](EntityFields.Orientation, map)\n      radius <- getOptional[Double](RobotFields.Radius, map)\n      speed <- getOptional[Double](RobotFields.Speed, map)\n      prox <- getOptional[Boolean](RobotFields.WithProximitySensors, map)\n      light <- getOptional[Boolean](RobotFields.WithLightSensors, map)\n      behavior <- getOptional[Policy](RobotFields.Behavior, map)\n    yield Robot().at(position)\n      |> (r => id.fold(r)(r.withId))\n      |> (r => orient.fold(r)(o => r.withOrientation(Orientation(o))))\n      |> (r => radius.fold(r)(radius => r.withShape(ShapeType.Circle(radius))))\n      |> (r => speed.fold(r)(s => r.withSpeed(s)))\n      |> (r => if prox.getOrElse(false) then r.withProximitySensors else r)\n      |> (r => if light.getOrElse(false) then r.withLightSensors else r)\n      |> (r => behavior.fold(r)(b => r.withBehavior(b)))\n"})}),"\n",(0,a.jsxs)(i.p,{children:["I metodi ",(0,a.jsx)(i.code,{children:"get"})," e ",(0,a.jsx)(i.code,{children:"getOptional"})," hanno le seguenti signature:"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"def get[A](field: String, map: Map[String, Any])(using decoder: Decoder[A]): ConfigResult[A]\ndef getOptional[A](field: String, map: Map[String, Any])(using decoder: Decoder[A]): ConfigResult[Option[A]]\n"})}),"\n",(0,a.jsxs)(i.p,{children:["Il ",(0,a.jsx)(i.code,{children:"decoder"})," \xe8 responsabile della conversione dei valori estratti dalla mappa nel tipo desiderato, gestendo eventuali errori di parsing in modo appropriato.\nL'utilizzo di ",(0,a.jsx)(i.code,{children:"decoder"})," tramite ",(0,a.jsx)(i.code,{children:"given"})," consente di semplificare il processo di decoding, rendendo il codice pi\xf9 pulito e leggibile."]}),"\n",(0,a.jsxs)(i.p,{children:["I ",(0,a.jsx)(i.code,{children:"decoder"})," sono definiti come istanze di ",(0,a.jsx)(i.code,{children:"Decoder[A]"}),":"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:'  given Decoder[Int] with\n\n    def decode(field: String, value: Any): ConfigResult[Int] =\n      value match\n        case n: Number =>\n          if n.intValue() == n.longValue() then Right[Seq[ConfigError], Int](n.intValue())\n          else Left[Seq[ConfigError], Int](Seq(ConfigError.InvalidType(field, "Int - value out of range")))\n        case s: String =>\n          try Right[Seq[ConfigError], Int](s.toInt)\n          catch\n            case _: NumberFormatException =>\n              Left[Seq[ConfigError], Int](Seq(ConfigError.InvalidType(field, "Int - invalid string format")))\n        case _ => Left[Seq[ConfigError], Int](Seq(ConfigError.InvalidType(field, "Int")))\n'})}),"\n",(0,a.jsxs)(i.p,{children:["Il metodo ",(0,a.jsx)(i.code,{children:"|>"})," \xe8 un operatore di piping che consente di passare il risultato di un'espressione come input alla successiva. Questo rende il codice pi\xf9 leggibile e consente di concatenare pi\xf9 operazioni in modo fluido. Ad esempio, nel parsing della configurazione ",(0,a.jsx)(i.em,{children:"YAML"}),", l'operatore ",(0,a.jsx)(i.code,{children:"|>"})," viene utilizzato per applicare una serie di trasformazioni all'istanza di ",(0,a.jsx)(i.code,{children:"Robot"})," in modo chiaro e conciso."]}),"\n",(0,a.jsx)(i.h2,{id:"serializzazione-della-configurazione",children:"Serializzazione della configurazione"}),"\n",(0,a.jsxs)(i.p,{children:["La libreria ",(0,a.jsx)(i.code,{children:"scala-yaml"})," non dispone di documentazione sufficiente per la definizione di serializzatori ",(0,a.jsx)(i.em,{children:"YAML"})," customizzati, pertanto per la serializzazione della configurazione \xe8 stata utilizzata una soluzione alternativa basata su ",(0,a.jsx)(i.a,{href:"https://github.com/circe/circe-yaml",children:"circe-yaml"}),".\nLa libreria nasce per la serializzazione e deserializzazione di dati in formato JSON, e fornisce un'estensione che consente di lavorare con il formato ",(0,a.jsx)(i.em,{children:"YAML"}),"."]}),"\n",(0,a.jsxs)(i.p,{children:["Per la serializzazione della configurazione, sono stati definiti ",(0,a.jsx)(i.code,{children:"Encoder"})," specifici per ciascun tipo di dato utilizzato nella configurazione."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"given Encoder[Robot] = (robot: Robot) =>\n  val dwt = robot.actuators.collectFirst { case dwt: DifferentialWheelMotor =>\n    dwt\n  }\n  val speeds = dwt.map(d => (d.left.speed, d.right.speed))\n  val withProximitySensors = StdProximitySensors.forall(robot.sensors.contains)\n  val withLightSensors = StdLightSensors.forall(robot.sensors.contains)\n  Json\n    .obj(\n      EntityFields.Id -> robot.id.asJson,\n      EntityFields.Position -> robot.position.asJson,\n      RobotFields.Radius -> robot.shape.radius.asJson,\n      EntityFields.Orientation -> robot.orientation.degrees.asJson,\n      RobotFields.WithProximitySensors -> withProximitySensors.asJson,\n      RobotFields.WithLightSensors -> withLightSensors.asJson,\n      RobotFields.Behavior -> robot.behavior.toString().asJson,\n    )\n    .deepMerge(\n      speeds.map(RobotFields.Speed -> _._1.asJson).toList.toMap.asJson,\n    )\n\n"})})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>t,x:()=>s});var o=n(6540);const a={},r=o.createContext(a);function t(e){const i=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:t(e.components),o.createElement(r.Provider,{value:i},e.children)}}}]);