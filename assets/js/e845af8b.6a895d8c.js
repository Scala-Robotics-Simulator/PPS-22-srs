"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6170],{8453:(e,i,n)=>{n.d(i,{R:()=>r,x:()=>l});var t=n(6540);const o={},a=t.createContext(o);function r(e){const i=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function l(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),t.createElement(a.Provider,{value:i},e.children)}},9583:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>s});const t=JSON.parse('{"id":"implementation/giulia-nardicchia/actuators","title":"Actuators","description":"In questa sezione sono descritti gli attuatori implementati nel progetto, che permettono di modificare lo stato delle","source":"@site/docs/05-implementation/04-giulia-nardicchia/actuators.md","sourceDirName":"05-implementation/04-giulia-nardicchia","slug":"/implementation/giulia-nardicchia/actuators","permalink":"/PPS-22-srs/docs/implementation/giulia-nardicchia/actuators","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Action","permalink":"/PPS-22-srs/docs/implementation/giulia-nardicchia/action"},"next":{"title":"Command Line Interface","permalink":"/PPS-22-srs/docs/implementation/giulia-nardicchia/cli"}}');var o=n(4848),a=n(8453);const r={},l="Actuators",c={},s=[{value:"DifferentialWheelMotor",id:"differentialwheelmotor",level:2},{value:"DifferentialKinematics",id:"differentialkinematics",level:2}];function d(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(i.header,{children:(0,o.jsx)(i.h1,{id:"actuators",children:"Actuators"})}),"\n",(0,o.jsx)(i.p,{children:"In questa sezione sono descritti gli attuatori implementati nel progetto, che permettono di modificare lo stato delle\nentit\xe0 dinamiche, in particolare la posizione e l'orientazione in base alle velocit\xe0 delle ruote."}),"\n",(0,o.jsxs)(i.p,{children:["L'interfaccia principale \xe8 ",(0,o.jsx)(i.code,{children:"Actuator"}),", che definisce il metodo ",(0,o.jsx)(i.code,{children:"act"})," per aggiornare lo stato di un'entit\xe0 dinamica\nin base al tempo trascorso e alle caratteristiche dell'attuatore:"]}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-scala",children:"trait Actuator[E <: DynamicEntity]:\n  def act[F[_] : Monad](dt: FiniteDuration, entity: E): F[E]\n"})}),"\n",(0,o.jsxs)(i.p,{children:["Il metodo \xe8 parametrizzato su una monade ",(0,o.jsx)(i.code,{children:"F[_]"}),", richiamando lo stile del ",(0,o.jsx)(i.strong,{children:"Tagless Final"}),", perch\xe9 consente di astrarre\nil contesto funzionale in cui l\u2019attuatore opera.\nTuttavia, l\u2019interfaccia non segue completamente il pattern ",(0,o.jsx)(i.strong,{children:"Tagless Final"})," \u201cpuro\u201d, in quanto non incapsula tutte le\noperazioni in un ",(0,o.jsx)(i.em,{children:"trait"})," parametrizzato su ",(0,o.jsx)(i.code,{children:"F[_]"}),". Si pu\xf2 quindi considerare una versione ispirata al ",(0,o.jsx)(i.strong,{children:"Tagless Final"}),",\nche combina flessibilit\xe0 e semplicit\xe0, permettendo di definire diversi tipi di attuatori senza propagare ",(0,o.jsx)(i.code,{children:"F[_]"}),"\nsull\u2019intero\nmodello ",(0,o.jsx)(i.code,{children:"Robot"}),"."]}),"\n",(0,o.jsxs)(i.p,{children:["\xc8 stato implementato solo un tipo di attuatore, ",(0,o.jsx)(i.code,{children:"DifferentialWheelMotor"}),".\nL'interfaccia ",(0,o.jsx)(i.code,{children:"Actuator"})," \xe8 progettata per essere estesa facilmente con nuovi tipi di attuatori."]}),"\n",(0,o.jsx)(i.h2,{id:"differentialwheelmotor",children:"DifferentialWheelMotor"}),"\n",(0,o.jsxs)(i.p,{children:[(0,o.jsx)(i.code,{children:"DifferentialWheelMotor"})," estende l'interfaccia ",(0,o.jsx)(i.code,{children:"Actuator[Robot]"})," e rappresenta un motore differenziale con velocit\xe0\nindipendenti per le ruote sinistra e destra. Le velocit\xe0 sono espresse in unit\xe0 al secondo (unit/s) e possono essere\npositive (avanti), negative (indietro) o nulle (fermo). Il motore differenziale utilizza la cinematica differenziale per\ncalcolare la nuova posizione e orientamento del robot in base alle velocit\xe0 delle ruote e al tempo trascorso."]}),"\n",(0,o.jsxs)(i.p,{children:["Il motore differenziale utilizza l'",(0,o.jsx)(i.em,{children:"object"})," ",(0,o.jsx)(i.code,{children:"DifferentialKinematics"})," per eseguire i calcoli necessari."]}),"\n",(0,o.jsx)(i.h2,{id:"differentialkinematics",children:"DifferentialKinematics"}),"\n",(0,o.jsxs)(i.p,{children:["Nell'",(0,o.jsx)(i.em,{children:"object"})," ",(0,o.jsx)(i.code,{children:"DifferentialKinematics"})," sono presenti tre funzioni principali che servono a calcolare la cinematica\ndifferenziale di un robot a due ruote."]}),"\n",(0,o.jsxs)(i.p,{children:["Si trattano di ",(0,o.jsx)(i.strong,{children:"funzioni di ordine superiore"})," (",(0,o.jsx)(i.em,{children:"higher-order functions"}),") perch\xe9 prendono parametri di configurazione e\nrestituiscono altre funzioni che eseguono i calcoli veri e propri."]}),"\n",(0,o.jsx)(i.p,{children:"Questo approccio permette di separare parametri:"}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsx)(i.li,{children:"statici: configurazione del robot (es. distanza tra le ruote, orientamento iniziale, delta time);"}),"\n",(0,o.jsx)(i.li,{children:"dinamici: valori che cambiano ad ogni tick della simulazione (es. velocit\xe0 delle ruote, velocit\xe0 lineare e\nangolare)."}),"\n"]}),"\n",(0,o.jsx)(i.admonition,{type:"info",children:(0,o.jsxs)(i.p,{children:["Le funzioni implementano le formule descritte nella\nsezione ",(0,o.jsx)(i.a,{href:"/PPS-22-srs/docs/detailed-design/entity#attuatori-di-movimento",children:"DifferentialKinematics"}),"\nper calcolare velocit\xe0, posizione e orientamento del robot."]})}),"\n",(0,o.jsx)(i.p,{children:"Le funzioni sono:"}),"\n",(0,o.jsx)(i.pre,{children:(0,o.jsx)(i.code,{className:"language-scala",children:"def computeWheelVelocities: DifferentialWheelMotor => (Double, Double)\ndef computeVelocities(wheelDistance: Double): ((Double, Double)) => (Double, Double)\ndef computePositionAndOrientation(theta: Double, dt: FiniteDuration): ((Double, Double)) => (Double, Double, Double)\n"})}),"\n",(0,o.jsxs)(i.ul,{children:["\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"computeWheelVelocities"}),": prende un motore differenziale e restituisce una tupla con le velocit\xe0 delle ruote sinistra\ne destra;"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"computeVelocities"}),": prende il parametro ",(0,o.jsx)(i.code,{children:"wheelDistance"})," (distanza tra le ruote) e restituisce una funzione\n",(0,o.jsx)(i.code,{children:"(vLeft: Double, vRight: Double) => (v: Double, omega: Double)"})," che calcola la velocit\xe0 lineare ",(0,o.jsx)(i.code,{children:"v"})," e la velocit\xe0\nangolare ",(0,o.jsx)(i.code,{children:"omega"})," del robot basandosi sulle velocit\xe0 delle ruote;"]}),"\n",(0,o.jsxs)(i.li,{children:[(0,o.jsx)(i.code,{children:"computePositionAndOrientation"}),": prende parametri di configurazione ",(0,o.jsx)(i.code,{children:"theta"})," (orientamento iniziale) e ",(0,o.jsx)(i.code,{children:"dt"})," (delta\ntime) e restituisce una funzione ",(0,o.jsx)(i.code,{children:"(v: Double, omega: Double) => (dx: Double, dy: Double, newOrientation: Double)"}),"\nche calcola lo spostamento (dx, dy), cio\xe8 la nuova posizione e la nuova orientazione del robot basandosi sulle\nvelocit\xe0 lineare e angolare."]}),"\n"]})]})}function u(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,o.jsx)(i,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);