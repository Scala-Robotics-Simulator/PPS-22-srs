"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8193],{1425:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>r});const o=JSON.parse('{"id":"implementation/giulia-nardicchia/mvc-implementation","title":"Model-View-Controller","description":"In questa sezione ci si concentra sull\'implementazione del Model, View e Controller della simulazione, seguendo il pattern architetturale Model-View-Controller (MVC) corredato dal Cake Pattern per la gestione delle dipendenze.","source":"@site/docs/05-implementation/04-giulia-nardicchia/mvc-implementation.md","sourceDirName":"05-implementation/04-giulia-nardicchia","slug":"/implementation/giulia-nardicchia/mvc-implementation","permalink":"/PPS-22-srs/docs/implementation/giulia-nardicchia/mvc-implementation","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"DSL per la creazione dell\'ambiente grid-based","permalink":"/PPS-22-srs/docs/implementation/giulia-nardicchia/dsl-environment-grid-based"},"next":{"title":"6. Retrospettiva","permalink":"/PPS-22-srs/docs/category/6-retrospettiva"}}');var l=n(4848),d=n(8453);const s={},a="Model-View-Controller",c={},r=[{value:"ModelModule",id:"modelmodule",level:2},{value:"ControllerModule",id:"controllermodule",level:2},{value:"Avvio della simulazione",id:"avvio-della-simulazione",level:3},{value:"Ciclo di simulazione",id:"ciclo-di-simulazione",level:3},{value:"Gestione degli eventi",id:"gestione-degli-eventi",level:3},{value:"LogicsBundle",id:"logicsbundle",level:3},{value:"Esecuzione dei comportamenti dei robot",id:"esecuzione-dei-comportamenti-dei-robot",level:3},{value:"ViewModule",id:"viewmodule",level:2}];function t(e){const i={admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(i.header,{children:(0,l.jsx)(i.h1,{id:"model-view-controller",children:"Model-View-Controller"})}),"\n",(0,l.jsxs)(i.p,{children:["In questa sezione ci si concentra sull'implementazione del Model, View e Controller della simulazione, seguendo il pattern architetturale ",(0,l.jsx)(i.strong,{children:"Model-View-Controller (MVC)"})," corredato dal ",(0,l.jsx)(i.strong,{children:"Cake Pattern"})," per la gestione delle dipendenze."]}),"\n",(0,l.jsx)(i.h2,{id:"modelmodule",children:"ModelModule"}),"\n",(0,l.jsxs)(i.p,{children:["Il trait ",(0,l.jsx)(i.code,{children:"Model[S]"})," \xe8 parametrizzato sul tipo di stato ",(0,l.jsx)(i.code,{children:"S"}),", che deve estendere ",(0,l.jsx)(i.code,{children:"State"}),".\nEsso definisce l\u2019interfaccia per aggiornare lo stato della simulazione in modo funzionale e sicuro."]}),"\n",(0,l.jsx)(i.p,{children:"Il metodo di aggiornamento \xe8 cos\xec definito:"}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-scala",children:"def update(s: S)(using f: S => IO[S]): IO[S]\n"})}),"\n",(0,l.jsx)(i.p,{children:"Esso accetta:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["lo stato corrente ",(0,l.jsx)(i.code,{children:"s"}),";"]}),"\n",(0,l.jsxs)(i.li,{children:["una funzione di aggiornamento ",(0,l.jsx)(i.code,{children:"f"}),", che produce, in modo asincrono, un nuovo stato incapsulato in ",(0,l.jsx)(i.code,{children:"IO"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["Grazie al parametro di contesto ",(0,l.jsx)(i.code,{children:"using"})," la logica di aggiornamento viene passata implicitamente: il ",(0,l.jsx)(i.code,{children:"Model"}),"\nnon deve conoscere quali eventi o regole hanno causato l\u2019aggiornamento; si limita ad applicare la funzione\nricevuta."]}),"\n",(0,l.jsxs)(i.blockquote,{children:["\n",(0,l.jsxs)(i.p,{children:["Nota: lo stato \xe8 immutabile: ogni aggiornamento produce una nuova istanza di ",(0,l.jsx)(i.code,{children:"State"}),", mantenendo\nl\u2019integrit\xe0 e la coerenza dei dati."]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["Il modulo segue il ",(0,l.jsx)(i.strong,{children:"Cake Pattern"}),", articolandosi in:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Provider[S]"}),": espone un\u2019istanza concreta di ",(0,l.jsx)(i.code,{children:"Model"})," agli altri moduli, permettendo l\u2019iniezione delle dipendenze;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Component[S]"}),": fornisce l\u2019implementazione concreta del ",(0,l.jsx)(i.code,{children:"Model"}),";"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Interface[S]"}),": combina ",(0,l.jsx)(i.code,{children:"Provider"})," e ",(0,l.jsx)(i.code,{children:"Component"}),", come interfaccia unificata del modulo."]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"ModelImpl"})," implementa ",(0,l.jsx)(i.code,{children:"update"})," semplicemente delegando l\u2019aggiornamento alla funzione passata tramite ",(0,l.jsx)(i.code,{children:"using"}),", rendendo l\u2019applicazione della logica di trasformazione completamente modulare e riutilizzabile."]}),"\n",(0,l.jsx)(i.h2,{id:"controllermodule",children:"ControllerModule"}),"\n",(0,l.jsxs)(i.p,{children:["Il trait ",(0,l.jsx)(i.code,{children:"Controller[S]"})," \xe8 parametrizzata sul tipo di stato ",(0,l.jsx)(i.code,{children:"S"}),", che estende ",(0,l.jsx)(i.code,{children:"ModelModule.State"}),".\nEsso espone due metodi:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"start"}),": avvia la simulazione;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"simulationLoop"}),": esegue il ciclo principale della simulazione."]}),"\n"]}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-scala",children:"def start(initialState: S): IO[S]\ndef simulationLoop(s: S, queue: Queue[IO, Event]): IO[S]\n"})}),"\n",(0,l.jsxs)(i.p,{children:["Il ",(0,l.jsx)(i.code,{children:"Controller"})," \xe8 responsabile dell\u2019avvio della simulazione, della gestione del ciclo di esecuzione e\ndegli eventi oltre alla comunicazione tra il ",(0,l.jsx)(i.code,{children:"Model"})," e la ",(0,l.jsx)(i.code,{children:"View"}),".\nL\u2019implementazione segue un approccio modulare e funzionale, sfruttando ",(0,l.jsx)(i.code,{children:"cats.effect"})," per la gestione della concorrenza\ned effetti asincroni."]}),"\n",(0,l.jsxs)(i.p,{children:["Il modulo segue il ",(0,l.jsx)(i.strong,{children:"Cake Pattern"}),", articolandosi in:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Provider[S]"}),": espone un\u2019istanza concreta di ",(0,l.jsx)(i.code,{children:"Controller"})," permettendo l\u2019iniezione del controller nei moduli\nche ne hanno bisogno;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Component[S]"}),": fornisce l\u2019implementazione concreta del ",(0,l.jsx)(i.code,{children:"Controller"})," (richiede ",(0,l.jsx)(i.code,{children:"ModelModule.Provider"}),"\ne ",(0,l.jsx)(i.code,{children:"ViewModule.Provider"}),");"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Interface[S]"}),": combina ",(0,l.jsx)(i.code,{children:"Provider"})," e ",(0,l.jsx)(i.code,{children:"Component"}),", operando da interfaccia unificata del modulo."]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"avvio-della-simulazione",children:"Avvio della simulazione"}),"\n",(0,l.jsxs)(i.p,{children:["Il metodo ",(0,l.jsx)(i.code,{children:"start"})," inizializza la simulazione creando una coda di eventi e avviando il ciclo di simulazione:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["utilizza ",(0,l.jsx)(i.code,{children:"Queue.unbounded[IO, Event]"})," per creare una coda di eventi asincrona e non bloccante;"]}),"\n",(0,l.jsxs)(i.li,{children:["avvia la ",(0,l.jsx)(i.em,{children:"View"})," chiamando ",(0,l.jsx)(i.code,{children:"context.view.init"}),", che prepara l\u2019interfaccia utente;"]}),"\n",(0,l.jsxs)(i.li,{children:["esegue i comportamenti dei robot con ",(0,l.jsx)(i.code,{children:"runBehavior"}),", che raccoglie in parallelo le proposte di azione dei robot;"]}),"\n",(0,l.jsxs)(i.li,{children:["infine, avvia il ciclo principale chiamando ",(0,l.jsx)(i.code,{children:"simulationLoop"})," passando lo stato iniziale e la coda degli eventi."]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"ciclo-di-simulazione",children:"Ciclo di simulazione"}),"\n",(0,l.jsxs)(i.p,{children:["Il metodo ",(0,l.jsx)(i.code,{children:"simulationLoop"})," implementa una funzione ricorsiva che:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["esegue i comportamenti dei robot se lo stato \xe8 ",(0,l.jsx)(i.code,{children:"RUNNING"}),";"]}),"\n",(0,l.jsxs)(i.li,{children:["recupera ed elabora gli eventi dalla coda (",(0,l.jsx)(i.code,{children:"handleEvents"}),");"]}),"\n",(0,l.jsxs)(i.li,{children:["aggiorna la vista con lo stato corrente (",(0,l.jsx)(i.code,{children:"context.view.render"}),");"]}),"\n",(0,l.jsxs)(i.li,{children:["verifica la condizione di stop tramite ",(0,l.jsx)(i.code,{children:"handleStopCondition"}),", che gestisce lo stato di terminazione della simulazione:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"STOPPED"}),": chiusura della view;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"ELAPSED_TIME"}),": passa alla view lo stato finale."]}),"\n"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["se la simulazione non termina, esegue ",(0,l.jsx)(i.code,{children:"nextStep"})," in base allo stato:","\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"RUNNING"}),": esegue ",(0,l.jsx)(i.code,{children:"tickEvents"}),", calcolando il tempo trascorso e regolando il tick in modo preciso;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"PAUSED"}),": sospende il ciclo per un breve intervallo (",(0,l.jsx)(i.code,{children:"50 ms"}),");"]}),"\n",(0,l.jsx)(i.li,{children:"altri stati: restituisce lo stato corrente senza modifiche."}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.li,{children:"ripete ricorsivamente il loop."}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"gestione-degli-eventi",children:"Gestione degli eventi"}),"\n",(0,l.jsx)(i.p,{children:"La gestione degli eventi \xe8 stata resa modulare e funzionale tramite due metodi:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"handleEvents"}),": processa una sequenza di eventi in ordine, applicando ciascun evento allo stato corrente;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"handleEvent"}),": gestisce un singolo evento, aggiornando lo stato tramite le logiche definite nel ",(0,l.jsx)(i.code,{children:"LogicsBundle"}),"."]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["Gli eventi (",(0,l.jsx)(i.code,{children:"Event"}),") comprendono:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Tick"}),": avanzamento temporale della simulazione;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"TickSpeed"}),": modifica della velocit\xe0 dei tick;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Random"}),": aggiornamento del generatore casuale;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Pause"})," / ",(0,l.jsx)(i.code,{children:"Resume"})," / ",(0,l.jsx)(i.code,{children:"Stop"}),": controllo dello stato della simulazione;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"RobotActionProposals"}),": gestione delle proposte di azione (",(0,l.jsx)(i.code,{children:"RobotProposal"}),") dei robot a ogni tick."]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["Ogni evento nel ",(0,l.jsx)(i.code,{children:"Controller"})," viene trasformato in un aggiornamento dello stato tramite le logiche definite nel\n",(0,l.jsx)(i.code,{children:"LogicsBundle"}),".\nIl ",(0,l.jsx)(i.code,{children:"LogicsBundle"})," viene passato implicitamente al controller come ",(0,l.jsx)(i.code,{children:"given"})," e utilizzato con la keyword ",(0,l.jsx)(i.code,{children:"using"})," quando il\n",(0,l.jsx)(i.code,{children:"Controller"})," chiama il metodo ",(0,l.jsx)(i.code,{children:"update"})," del model."]}),"\n",(0,l.jsxs)(i.admonition,{type:"tip",children:[(0,l.jsxs)(i.mdxAdmonitionTitle,{children:["Esempio di gestione di un evento ",(0,l.jsx)(i.code,{children:"Tick"})]}),(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-scala",children:"// ...\ncase Event.Tick(elapsed) =>\n  context.model.update(s)(using context.logics.tick(elapsed))\n// ...\n"})})]}),"\n",(0,l.jsx)(i.p,{children:"In questo modo:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["il ",(0,l.jsx)(i.code,{children:"Controller"})," non modifica direttamente lo stato, ma delega tutte le trasformazioni al ",(0,l.jsx)(i.code,{children:"Model"}),", specificando quale logica applicare (",(0,l.jsx)(i.code,{children:"tick"}),", ",(0,l.jsx)(i.code,{children:"pause"}),", ",(0,l.jsx)(i.code,{children:"stop"}),", ",(0,l.jsx)(i.code,{children:"resume"}),", ecc.);"]}),"\n",(0,l.jsxs)(i.li,{children:["il ",(0,l.jsx)(i.code,{children:"Model"})," applica la logica appropriata e restituisce il nuovo stato aggiornato."]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["Questo consente al ",(0,l.jsx)(i.code,{children:"Controller"})," di continuare il ciclo della simulazione con lo stato corretto, senza occuparsi\ndirettamente delle regole di aggiornamento o dei dettagli della business logic."]}),"\n",(0,l.jsx)(i.h3,{id:"logicsbundle",children:"LogicsBundle"}),"\n",(0,l.jsxs)(i.p,{children:["Il ",(0,l.jsx)(i.code,{children:"LogicsBundle"})," raccoglie le funzioni che definiscono come lo stato della simulazione viene aggiornato in risposta a\ndiversi eventi.\nOgni funzione prende lo stato corrente e, se necessario, parametri aggiuntivi, restituendo un nuovo stato aggiornato.\nLe funzioni incluse sono:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"tick"}),": aggiorna lo stato della simulazione avanzando il tempo trascorso e, se necessario, modificando lo stato in\nbase al tempo massimo raggiunto;"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"tickSpeed"}),": modifica la velocit\xe0 della simulazione;"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"random"}),": aggiorna il generatore di numeri casuali nello stato;"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"pause"}),": mette la simulazione in pausa aggiornando lo stato;"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"resume"}),": riprende la simulazione aggiornando lo stato;"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"stop"}),": ferma la simulazione aggiornando lo stato;"]}),"\n"]}),"\n",(0,l.jsxs)(i.li,{children:["\n",(0,l.jsxs)(i.p,{children:[(0,l.jsx)(i.code,{children:"robotActions"}),": gestisce le proposte di azione dei robot (",(0,l.jsx)(i.code,{children:"RobotProposal"}),") e aggiorna lo stato della simulazione\n(",(0,l.jsx)(i.code,{children:"SimulationState"}),") di conseguenza."]}),"\n",(0,l.jsx)(i.p,{children:"Per ciascuna proposta:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["si applica l\u2019azione del robot all\u2019ambiente usando una ",(0,l.jsx)(i.strong,{children:"ricerca binaria"})," per\ncalcolare la massima durata di movimento sicura ( evitando collisioni con altri oggetti o robot);"]}),"\n",(0,l.jsxs)(i.li,{children:["i movimenti di tutti i robot vengono calcolati in parallelo usando ",(0,l.jsx)(i.code,{children:"parTraverse"}),";"]}),"\n",(0,l.jsxs)(i.li,{children:["i robot aggiornati sostituiscono quelli originali nell\u2019ambiente simulato, mantenendo la\nvalidit\xe0 dell\u2019ambiente tramite la funzione di ",(0,l.jsx)(i.code,{children:"validate"}),";"]}),"\n",(0,l.jsx)(i.li,{children:"se la validazione fallisce, lo stato dell\u2019ambiente non viene modificato."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,l.jsx)(i.h3,{id:"esecuzione-dei-comportamenti-dei-robot",children:"Esecuzione dei comportamenti dei robot"}),"\n",(0,l.jsxs)(i.p,{children:["Il metodo ",(0,l.jsx)(i.code,{children:"runBehavior"})," seleziona tutte le entit\xe0 di tipo ",(0,l.jsx)(i.code,{children:"Robot"})," presenti nell\u2019ambiente."]}),"\n",(0,l.jsx)(i.p,{children:"Per ciascun robot:"}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:["legge i sensori (",(0,l.jsx)(i.code,{children:"senseAll"}),");"]}),"\n",(0,l.jsxs)(i.li,{children:["costruisce un ",(0,l.jsx)(i.code,{children:"BehaviorContext"})," (letture sensori + RNG) e calcola l\u2019azione con ",(0,l.jsx)(i.code,{children:"robot.behavior.run"}),";"]}),"\n",(0,l.jsxs)(i.li,{children:["aggiorna il generatore casuale della simulazione (",(0,l.jsx)(i.code,{children:"Event.Random"}),") con quello restituito dal comportamento;"]}),"\n",(0,l.jsxs)(i.li,{children:["crea una proposta di azione (",(0,l.jsx)(i.code,{children:"RobotProposal"}),");"]}),"\n",(0,l.jsxs)(i.li,{children:["inserisce in coda un evento ",(0,l.jsx)(i.code,{children:"RobotActionProposals"})," contenente tutte le proposte di azione raccolte."]}),"\n"]}),"\n",(0,l.jsx)(i.p,{children:"Questo approccio permette di calcolare i comportamenti in parallelo, riducendo i tempi di elaborazione e mantenendo\nl\u2019aggiornamento dello stato coerente."}),"\n",(0,l.jsx)(i.h2,{id:"viewmodule",children:"ViewModule"}),"\n",(0,l.jsxs)(i.p,{children:["Il trait ",(0,l.jsx)(i.code,{children:"View[S]"})," definisce l\u2019interfaccia della view, parametrizzata sul tipo di stato ",(0,l.jsx)(i.code,{children:"S"})," che estende\n",(0,l.jsx)(i.code,{children:"ModelModule.State"}),". La view espone quattro operazioni principali:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"init"}),": inizializza la view e collega la coda degli eventi del controller, in modo\nche la view possa ricevere e reagire agli eventi;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"render"}),": aggiorna la visualizzazione in base allo stato corrente della simulazione, mostrando i\ncambiamenti dell'ambiente e delle entit\xe0;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"close"}),": chiude la view e libera le risorse;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"timeElapsed"}),": gestisce le azioni da eseguire quando il tempo massimo della simulazione \xe8\nraggiunto."]}),"\n"]}),"\n",(0,l.jsx)(i.pre,{children:(0,l.jsx)(i.code,{className:"language-scala",children:"def init(queue: Queue[IO, Event]): IO[Unit]\ndef render(state: S): IO[Unit]\ndef close(): IO[Unit]\ndef timeElapsed(state: S): IO[Unit]\n"})}),"\n",(0,l.jsxs)(i.p,{children:["Queste operazioni sono tutte implementate come effetti ",(0,l.jsx)(i.code,{children:"IO"}),", consentendo di gestire in modo sicuro e non bloccante\nl\u2019aggiornamento della ",(0,l.jsx)(i.code,{children:"UI"})," e la sincronizzazione con il ciclo di simulazione."]}),"\n",(0,l.jsxs)(i.p,{children:["Il modulo segue il ",(0,l.jsx)(i.strong,{children:"Cake Pattern"}),", articolandosi in:"]}),"\n",(0,l.jsxs)(i.ul,{children:["\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Provider[S]"}),": espone un\u2019istanza concreta della ",(0,l.jsx)(i.code,{children:"View"})," agli altri moduli, supportando l\u2019iniezione delle dipendenze;"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Component[S]"}),": definisce l\u2019implementazione concreta della view tramite ",(0,l.jsx)(i.code,{children:"makeView()"}),", usato per costruire nuove istanze (richiede ",(0,l.jsx)(i.code,{children:"ControllerModule.Provider"}),");"]}),"\n",(0,l.jsxs)(i.li,{children:[(0,l.jsx)(i.code,{children:"Interface[S]"}),": combina ",(0,l.jsx)(i.code,{children:"Provider"})," e ",(0,l.jsx)(i.code,{children:"Component"}),", offrendo un\u2019unica interfaccia al resto della simulazione."]}),"\n"]}),"\n",(0,l.jsxs)(i.p,{children:["In questo modo, la ",(0,l.jsx)(i.code,{children:"View"})," resta indipendente e intercambiabile: \xe8 possibile fornire implementazioni diverse (ad esempio, CLI o GUI) senza modificare le logiche di simulazione."]})]})}function h(e={}){const{wrapper:i}={...(0,d.R)(),...e.components};return i?(0,l.jsx)(i,{...e,children:(0,l.jsx)(t,{...e})}):t(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>a});var o=n(6540);const l={},d=o.createContext(l);function s(e){const i=o.useContext(d);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:s(e.components),o.createElement(d.Provider,{value:i},e.children)}}}]);