"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8030],{1612:(e,i,n)=>{n.d(i,{A:()=>o});const o=n.p+"assets/images/configuration-8b35aefef650876f8ca5b75eb0883427.png"},4315:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>t,contentTitle:()=>s,default:()=>g,frontMatter:()=>l,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"detailed-design/configuration","title":"Configuration","description":"Il package io.github.srs.config fornisce le classi necessarie per gestire la configurazione della simulazione.","source":"@site/docs/04-detailed-design/08-configuration.md","sourceDirName":"04-detailed-design","slug":"/detailed-design/configuration","permalink":"/PPS-22-srs/docs/detailed-design/configuration","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":8,"frontMatter":{"sidebar_position":8},"sidebar":"docsSidebar","previous":{"title":"Action","permalink":"/PPS-22-srs/docs/detailed-design/action"},"next":{"title":"Illumination","permalink":"/PPS-22-srs/docs/detailed-design/illumination"}}');var r=n(4848),a=n(8453);const l={sidebar_position:8},s="Configuration",t={},c=[{value:"Architettura",id:"architettura",level:2},{value:"Tagless final pattern",id:"tagless-final-pattern",level:3},{value:"Gestione degli errori",id:"gestione-degli-errori",level:2}];function d(e){const i={a:"a",admonition:"admonition",blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.header,{children:(0,r.jsx)(i.h1,{id:"configuration",children:"Configuration"})}),"\n",(0,r.jsxs)(i.p,{children:["Il package ",(0,r.jsx)(i.code,{children:"io.github.srs.config"})," fornisce le classi necessarie per gestire la configurazione della simulazione.\nViene utilizzata per permettere di salvare e caricare le impostazioni della simulazione, come ad esempio il ",(0,r.jsx)(i.code,{children:"seed"})," e la durata della simulazione, oltre a configurare le caratteristiche dell'ambiente di simulazione, ovvero la dimensione e il numero di entit\xe0 presenti.\nLe operazioni di salvataggio e caricamento sono gestite dal ",(0,r.jsx)(i.em,{children:"trait"})," ",(0,r.jsx)(i.code,{children:"ConfigManager"}),", un'interfaccia agnostica che permette di gestire la configurazione in modo indipendente dal formato di salvataggio."]}),"\n",(0,r.jsxs)(i.blockquote,{children:["\n",(0,r.jsxs)(i.p,{children:["Nota: al momento \xe8 possibile utilizzare solamente il formato ",(0,r.jsx)(i.em,{children:"YAML"}),".\nLe operazioni che vengono effettuate sono le seguenti:"]}),"\n"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["caricamento (",(0,r.jsx)(i.code,{children:"load"}),") della configurazione da un file ",(0,r.jsx)(i.em,{children:"YAML"}),";"]}),"\n",(0,r.jsxs)(i.li,{children:["salvataggio (",(0,r.jsx)(i.code,{children:"save"}),") della configurazione su un file ",(0,r.jsx)(i.em,{children:"YAML"}),"."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:["Durante l'esecuzione della funzione ",(0,r.jsx)(i.code,{children:"load"}),", viene effettuato un controllo sulla validit\xe0 della configurazione, per garantire che i parametri siano corretti e che non vi siano errori di formattazione o valori non validi."]}),"\n",(0,r.jsx)(i.p,{children:(0,r.jsx)(i.img,{alt:"Configuration",src:n(1612).A+"",width:"4413",height:"2013"})}),"\n",(0,r.jsx)(i.h2,{id:"architettura",children:"Architettura"}),"\n",(0,r.jsxs)(i.p,{children:["L'architettura di ",(0,r.jsx)(i.code,{children:"ConfigManager"})," adotta un approccio ",(0,r.jsx)(i.em,{children:"funzionale e parametrico"})," basato su ",(0,r.jsx)(i.code,{children:"F[_]"}),", rendendo il codice agnostico rispetto all'effetto utilizzato per l'esecuzione (es. ",(0,r.jsx)(i.code,{children:"IO"}),", ",(0,r.jsx)(i.code,{children:"SyncIO"}),", ",(0,r.jsx)(i.code,{children:"Task"}),")."]}),"\n",(0,r.jsx)(i.p,{children:"L'implementazione prevede:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ConfigManager[F[_]]"}),": un'interfaccia che definisce le operazioni di caricamento e salvataggio della configurazione (",(0,r.jsx)(i.em,{children:"algebra"}),");"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"YamlConfigManager[F[_]]"}),": un'implementazione di ",(0,r.jsx)(i.code,{children:"ConfigManager"})," che utilizza il formato ",(0,r.jsx)(i.em,{children:"YAML"})," per la configurazione (",(0,r.jsx)(i.em,{children:"interprete"}),");"]}),"\n",(0,r.jsxs)(i.li,{children:["utility di parsing e serializzazione (",(0,r.jsx)(i.code,{children:"YamlManager"}),", ",(0,r.jsx)(i.code,{children:"YamlSimulationConfigParser"}),", ",(0,r.jsx)(i.code,{children:"YamlSimulationConfigSerializer"}),"): gestiscono la conversione tra oggetti Scala e rappresentazioni ",(0,r.jsx)(i.em,{children:"YAML"}),";"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ConfigError"})," e ",(0,r.jsx)(i.code,{children:"ConfigResult[A]"}),": tipi per gestire gli errori di configurazione e i risultati delle operazioni di caricamento e salvataggio."]}),"\n"]}),"\n",(0,r.jsx)(i.h3,{id:"tagless-final-pattern",children:"Tagless final pattern"}),"\n",(0,r.jsxs)(i.p,{children:["Il ",(0,r.jsx)(i.code,{children:"ConfigManager[F[_]]"})," segue il ",(0,r.jsx)(i.strong,{children:"tagless final pattern"}),": le operazioni sono parametrizzate su un tipo di effetto ",(0,r.jsx)(i.code,{children:"F[_]"})," e vincolate solo alle capacit\xe0 necessarie, ad esempio ",(0,r.jsx)(i.code,{children:"Sync"})," e ",(0,r.jsx)(i.code,{children:"Files"})," per ",(0,r.jsx)(i.code,{children:"YamlConfigManager[F[_]]"}),".\nI vincoli di tipo (",(0,r.jsx)(i.code,{children:"cats.effect.Sync"})," e ",(0,r.jsx)(i.code,{children:"fs2.Files"}),") definiscono le capacit\xe0 richieste - sospendere side-effect e interagire con il file system - senza imporre implementazioni concrete."]}),"\n",(0,r.jsxs)(i.p,{children:["A differenza di ",(0,r.jsx)(i.a,{href:"/PPS-22-srs/docs/detailed-design/action",children:"Action"}),", non \xe8 stata suddivisa l'algebra dall'interfaccia, ma saranno le diverse implementazioni a fornire le concrete realizzazioni delle operazioni.",(0,r.jsx)(i.br,{}),"\n","In questo contesto si distinguono quindi:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"algebra"}),": il trait ",(0,r.jsx)(i.code,{children:"ConfigManager"}),", che definisce le operazioni disponibili senza specificare come debbano essere implementate;"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.strong,{children:"interpreti"}),": le varie implementazioni concrete dell\u2019algebra. Ad esempio ",(0,r.jsx)(i.code,{children:"YamlConfigManager[F]"})," interpreta le operazioni leggendo e scrivendo file YAML, mentre in futuro potrebbero esserci interpreti diversi (es. ",(0,r.jsx)(i.code,{children:"JsonConfigManager[F]"})," o un interprete in-memory per i test)."]}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Questo approccio consente:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"indipendenza dal tipo di effetto specifico utilizzato per l'esecuzione;"}),"\n",(0,r.jsx)(i.li,{children:"migliore testabilit\xe0 tramite interpreti fittizi o mock;"}),"\n",(0,r.jsxs)(i.li,{children:["separazione netta tra la definizione dell'algebra (",(0,r.jsx)(i.code,{children:"ConfigManager"}),") e le implementazioni concrete (",(0,r.jsx)(i.em,{children:"interpreti"})," come ",(0,r.jsx)(i.code,{children:"YamlConfigManager"}),")."]}),"\n"]}),"\n",(0,r.jsx)(i.h2,{id:"gestione-degli-errori",children:"Gestione degli errori"}),"\n",(0,r.jsxs)(i.p,{children:["La gestione degli errori durante il caricamento della configurazione \xe8 stata gestita tramite il tipo ",(0,r.jsx)(i.code,{children:"ConfigResult[A]"})," (alias per ",(0,r.jsx)(i.code,{children:"Either[Seq[ConfigError], A]"}),").\nRappresenta il risultato di un'operazione di configurazione e pu\xf2 essere un successo (",(0,r.jsx)(i.code,{children:"Right"}),") o un fallimento (",(0,r.jsx)(i.code,{children:"Left"}),")."]}),"\n",(0,r.jsxs)(i.p,{children:["I tipi di errore sono definiti in ",(0,r.jsx)(i.code,{children:"ConfigError"}),", che include:"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"MissingField"}),": un campo obbligatorio mancante;"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"ParsingError"}),": un errore durante il parsing del file di configurazione, tipicamente causato dall'utilizzo di chiavi non valide;"]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"InvalidType"}),": un tipo di dato non valido per un campo specifico."]}),"\n"]}),"\n",(0,r.jsx)(i.admonition,{type:"info",children:(0,r.jsxs)(i.p,{children:["I dettagli implementativi riguardanti la configurazione sono disponibili nella sezione ",(0,r.jsx)(i.a,{href:"/PPS-22-srs/docs/implementation/simone-ceredi/configuration",children:"Implementazione della configurazione"}),"."]})})]})}function g(e={}){const{wrapper:i}={...(0,a.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>l,x:()=>s});var o=n(6540);const r={},a=o.createContext(r);function l(e){const i=o.useContext(a);return o.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function s(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),o.createElement(a.Provider,{value:i},e.children)}}}]);