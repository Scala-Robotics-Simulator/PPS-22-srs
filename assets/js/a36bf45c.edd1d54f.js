"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1313],{4165:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>t,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>r});const l=JSON.parse('{"id":"implementation/david-cohen/illumination","title":"Illumination","description":"Pipeline di calcolo","source":"@site/docs/05-implementation/03-david-cohen/illumination.md","sourceDirName":"05-implementation/03-david-cohen","slug":"/implementation/david-cohen/illumination","permalink":"/PPS-22-srs/docs/implementation/david-cohen/illumination","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"David Cohen","permalink":"/PPS-22-srs/docs/implementation/david-cohen/"},"next":{"title":"Behavior","permalink":"/PPS-22-srs/docs/implementation/david-cohen/behaviors"}}');var a=n(4848),o=n(8453);const s={sidebar_position:2},t="Illumination",c={},r=[{value:"Pipeline di calcolo",id:"pipeline-di-calcolo",level:2},{value:"Rasterizzazione delle occlusioni",id:"rasterizzazione-delle-occlusioni",level:3},{value:"Calcolo e combinazione del campo luminoso",id:"calcolo-e-combinazione-del-campo-luminoso",level:3},{value:"Engine FOV pluggable",id:"engine-fov-pluggable",level:3},{value:"LightField: query dai sensori",id:"lightfield-query-dai-sensori",level:3},{value:"Type-safe scale e dimensioni",id:"type-safe-scale-e-dimensioni",level:3},{value:"Integrazione con environment",id:"integrazione-con-environment",level:3},{value:"Facade LightMap (Effect-Aware)",id:"facade-lightmap-effect-aware",level:3},{value:"Tagless final pattern",id:"tagless-final-pattern",level:4},{value:"Configurazioni disponibili",id:"configurazioni-disponibili",level:3},{value:"Motivazioni per la scelta di SquidLib",id:"motivazioni-per-la-scelta-di-squidlib",level:2}];function d(e){const i={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(i.header,{children:(0,a.jsx)(i.h1,{id:"illumination",children:"Illumination"})}),"\n",(0,a.jsx)(i.h2,{id:"pipeline-di-calcolo",children:"Pipeline di calcolo"}),"\n",(0,a.jsxs)(i.p,{children:["La funzione ",(0,a.jsx)(i.code,{children:"computeLightField"})," orchestra la pipeline:"]}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"dimensionamento"}),": traduce lo spazio continuo in una griglia discreta (in funzione di ",(0,a.jsx)(i.code,{children:"ScaleFactor"}),");"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"occlusione"}),": costruisce la mappa di occlusione a partire dall\u2019ambiente (ostacoli e dinamici opzionali);"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"combinazione"}),": calcola il contributo di ogni luce e li somma in un unico campo luminoso (",(0,a.jsx)(i.code,{children:"LightField"}),")."]}),"\n"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"def computeLightField(scale: ScaleFactor)(fov: FovEngine)\n                     (includeDynamic: Boolean)(env: Environment): LightField = {\n  given ScaleFactor = scale\n\n  // 1) dimensionamento\n  val dims = GridDims.from(env)(scale)\n  val lights = env.lights.toVector\n\n  // 2) occlusione\n  val occlusion = computeOcclusion(env, dims, includeDynamic)\n\n  // 3) Calcola e combina i contributi di tutte le luci\n  computeField(dims, lights, occlusion, fov)\n}\n"})}),"\n",(0,a.jsx)(i.h3,{id:"rasterizzazione-delle-occlusioni",children:"Rasterizzazione delle occlusioni"}),"\n",(0,a.jsx)(i.p,{children:"La conversione delle geometrie in occlusioni \xe8 ottimizzata per ogni forma:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"cerchi"}),": algoritmo scan-line fill;"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"rettangoli"})," allineati: fast path che riempie direttamente l'area;"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"rettangoli ruotati"}),": test inverse-rotate sul centro di ogni cella all'interno di un'area di interesse ristretta."]}),"\n"]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"// OcclusionRaster.scala (estratto)\ndef rasterizeStatics(env, dims)(using ScaleFactor) =\n  rasterizeEntities(env.entities.collect { case ob: StaticEntity.Obstacle => ob }, dims)\n\ndef rasterizeDynamics(env, dims)(using ScaleFactor) =\n  rasterizeEntities(env.entities.collect { case d: DynamicEntity => d }, dims)\n\nprivate def rasterizeCircle(center: Point2D, radius: Double, dims: GridDims)\n                           (using s: ScaleFactor): Iterator[Int] = {\n  // Scanline: per ogni riga che interseca il cerchio, riempi lo span [minX,maxX]\n  // Indice lineare: dims.toIndex(x,y)\n...\n}\n\nprivate def rasterizeAxisAlignedRect(center, w, h, orientation, dims)\n                                    (using s: ScaleFactor): Iterator[Int] = {\n  // Rettangoli allineati: riempi AABB (con fast-path per 0/90/180/270)\n...\n}\n\nprivate def rasterizeRotatedRect(center, w, h, orientation, dims)\n                                (using s: ScaleFactor): Iterator[Int] = {\n  // AABB stretta in world-space \u2192 inverse-rotate il centro cella \u2192 inside test\n...\n}\n\ndef combine(base, overlay) = Grid.overlayMax(base, overlay) // max per cella (0/1)\n"})}),"\n",(0,a.jsx)(i.h3,{id:"calcolo-e-combinazione-del-campo-luminoso",children:"Calcolo e combinazione del campo luminoso"}),"\n",(0,a.jsxs)(i.p,{children:["Per ogni campo luminoso, si calcola un campo locale con ",(0,a.jsx)(i.code,{children:"FovEngine"})," e lo si riduce. La combinazione pu\xf2 essere\nparallelizzata in modo adattivo in base alla dimensione della griglia e al numero di luci.\nPer ottimizzare, si usano guardie (bounds, raggio, intensit\xe0) per evitare computazione inutile.\nInfine, per ottenere la somma dei contributi si usa una somma saturata (",(0,a.jsx)(i.code,{children:"zipSat"}),") per mantenere i valori in ",(0,a.jsx)(i.code,{children:"[0,1]"}),"."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"\n// IlluminationLogic.scala (estratto)\n\nprivate def computeField(dims, lights, occlusion, fov)(using scale: ScaleFactor): LightField = {\n  val shouldPar = dims.totalCells >= Illumination.GridThreshold ||\n\n  lights.sizeIs >= Illumination.LightThreshold\n\n  val perLight = computeAllLightContributions(lights, dims, occlusion, fov, shouldPar)\n\n  val combined = perLight match\n    case Vector() => ArraySeq.fill(dims.totalCells)(0.0)\n    case Vector(single) => single\n    case many =>\n      if (!shouldPar && many.sizeIs >= Illumination.LightThreshold)\n        combineParallel(many)\n      else\n        combineSequential(dims.totalCells, many)\n  LightField(dims, combined)\n\n}\n\n\nprivate def computeSingleLightContribution(dims, occlusion, fov, light)(using scale: ScaleFactor): Field = {\n...\n  val (cx, cy) = Cell.toCellFloor(light.position)\n\n  val radiusInCells = Cell.radiusCells(light.illuminationRadius).toDouble\n\n  val intensity = clampTo01(light.intensity)\n\n  if (!dims.inBounds(cx, cy) || intensity == 0.0 || radiusInCells <= 0.0)\n    ArraySeq.fill(dims.totalCells)(0.0)\n  else {\n    val raw = fov.compute(occlusion)(cx, cy, radiusInCells)\n\n    applyIntensity(intensity, raw)\n\n  }\n}\n\n"})}),"\n",(0,a.jsx)(i.h3,{id:"engine-fov-pluggable",children:"Engine FOV pluggable"}),"\n",(0,a.jsxs)(i.p,{children:["L'interfaccia ",(0,a.jsx)(i.code,{children:"FovEngine"})," astrae l'algoritmo di propagazione della luce. L'implementazione pu\xf2 essere sostituita senza\nmodificare il resto della pipeline, permettendo di sperimentare con diversi profili di decadimento."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"// engine/FovEngine.scala\ntrait FovEngine {\n  def compute(occlusion: Grid[Double])\n             (startX: Int, startY: Int, radius: Double): ArraySeq[Double]\n}\n\n// engine/SquidLibFovEngine.scala\nobject SquidLibFovEngine extends FovEngine {\n  def compute(occ)(sx, sy, r) = {\n    val buffer = Array.ofDim[Double](occ.width, occ.height)\n    FOV.reuseFOV(occ, buffer, sx, sy, r)\n    buffer.flattenRowMajor // row-major, x-fast\n  }\n}\n"})}),"\n",(0,a.jsx)(i.h3,{id:"lightfield-query-dai-sensori",children:"LightField: query dai sensori"}),"\n",(0,a.jsxs)(i.p,{children:["Il ",(0,a.jsx)(i.code,{children:"LightField"})," \xe8 il dato finale utilizzato dai sensori: prende coordinate continue e restituisce un valore ",(0,a.jsx)(i.em,{children:"smooth"}),"\ngrazie all\u2019interpolazione bilineare sulle quattro celle adiacenti. Fuori dai confini, il valore \xe8 0.0 per un\ncomportamento prevedibile."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"// model/LightField.scala (estratto)\nfinal case class LightField(dims: GridDims, data: ArraySeq[Double]) {\n  def illuminationAt(pos: Point2D)(using scale: ScaleFactor): Double = {\n    val gridX = pos.x * scale\n    val gridY = pos.y * scale\n    if (pos.x < 0 || pos.y < 0) 0.0\n    else bilinearInterpolate(gridX, gridY)\n  }\n\n  private def bilinearInterpolate(gx: Double, gy: Double): Double = {\n    // Interpolazione bilineare tra le 4 celle circostanti\n  ...\n  }\n}\n"})}),"\n",(0,a.jsx)(i.h3,{id:"type-safe-scale-e-dimensioni",children:"Type-safe scale e dimensioni"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.code,{children:"ScaleFactor"})," \xe8 un ",(0,a.jsx)(i.em,{children:"tipo opaco"})," (",(0,a.jsx)(i.code,{children:"opaque type"}),') che incapsula un intero con validazione (1..1000). Questo previene\nerrori di configurazione e rende esplicita la sua semantica di "celle per metro".']}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:'// model/ScaleFactor.scala\nopaque type ScaleFactor = Int\n\nobject ScaleFactor:\n  def validate(n: Int): Validation[ScaleFactor] =\n    bounded("ScaleFactor", n, 1, 1000, includeMax = true).map(v => v: ScaleFactor)\n\n...\n'})}),"\n",(0,a.jsx)(i.h3,{id:"integrazione-con-environment",children:"Integrazione con environment"}),"\n",(0,a.jsxs)(i.p,{children:["Il campo luce \xe8 un ",(0,a.jsx)(i.code,{children:"lazy val"}),", quindi viene calcolato on-demand al primo accesso e poi riusato in modo da fare caching.\nIn caso le entit\xe0 o luci cambiano o semplicemente si vuole aggiornare il campo, bisogna ri-elaborare attraverso la\n",(0,a.jsx)(i.code,{children:"LightMap"})," o ricreare l\u2019",(0,a.jsx)(i.code,{children:"Environment"}),"."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"// Environment.scala\nfinal case class Environment(\n\n...,\nprivate[environment] val _lightMap: Option[LightMap[IO]] = None\n):\n\nprivate val lightMap: LightMap[IO] =\n  _lightMap.getOrElse(LightMapConfigs.BaseLightMap)\n\nlazy val lightField: LightField =\n  lightMap.computeField(this, includeDynamic = true).unsafeRunSync()\n"})}),"\n",(0,a.jsx)(i.h3,{id:"facade-lightmap-effect-aware",children:"Facade LightMap (Effect-Aware)"}),"\n",(0,a.jsxs)(i.p,{children:["La facade ",(0,a.jsx)(i.code,{children:"LightMap"})," isola il codice di calcolo dai side-effect (come l'esecuzione asincrona gestita da ",(0,a.jsx)(i.code,{children:"IO"})," di ",(0,a.jsx)(i.code,{children:"cats.effect"}),")."]}),"\n",(0,a.jsx)(i.pre,{children:(0,a.jsx)(i.code,{className:"language-scala",children:"// LightMap.scala\ntrait LightMap[F[_]]:\n  def computeField(env: Environment, includeDynamic: Boolean): F[LightField]\n"})}),"\n",(0,a.jsx)(i.h4,{id:"tagless-final-pattern",children:"Tagless final pattern"}),"\n",(0,a.jsxs)(i.p,{children:[(0,a.jsx)(i.code,{children:"LightMap"})," segue il ",(0,a.jsx)(i.strong,{children:"tagless final pattern"}),": le operazioni sono parametrizzate su un tipo di effetto ",(0,a.jsx)(i.code,{children:"F[_]"})," e vincolate solo alle capacit\xe0 necessarie, ad esempio ",(0,a.jsx)(i.code,{children:"Sync"})," nel caso di ",(0,a.jsx)(i.code,{children:"LightMapImpl"}),".\nIl vincolo di tipo (",(0,a.jsx)(i.code,{children:"cats.effect.Sync"}),") definisce le capacit\xe0 richieste - sospendere side-effect - senza imporre implementazioni concrete."]}),"\n",(0,a.jsx)(i.p,{children:"In questo contesto si distinguono quindi:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"algebra"}),": il trait ",(0,a.jsx)(i.code,{children:"LightMap"}),", che definisce le operazioni disponibili senza specificare come debbano essere implementate;"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"interpreti"}),": le varie implementazioni concrete dell\u2019algebra. Ad esempio ",(0,a.jsx)(i.code,{children:"LightMapImpl[F]"})," interpreta le operazioni eseguendo i calcoli richiesti, mentre in futuro potrebbero esserci interpreti diversi."]}),"\n"]}),"\n",(0,a.jsx)(i.p,{children:"Questo approccio consente:"}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"indipendenza dal tipo di effetto specifico utilizzato per l'esecuzione;"}),"\n",(0,a.jsx)(i.li,{children:"migliore testabilit\xe0 tramite interpreti fittizi o mock;"}),"\n",(0,a.jsxs)(i.li,{children:["separazione netta tra la definizione dell'algebra (",(0,a.jsx)(i.code,{children:"LightMap"}),") e le implementazioni concrete (",(0,a.jsx)(i.em,{children:"interpreti"})," come ",(0,a.jsx)(i.code,{children:"LightMapImpl"}),")."]}),"\n"]}),"\n",(0,a.jsx)(i.h3,{id:"configurazioni-disponibili",children:"Configurazioni disponibili"}),"\n",(0,a.jsxs)(i.p,{children:["Il preset viene scelto tramite DSL senza toccare il core. Sono presenti tre preset nel ",(0,a.jsx)(i.code,{children:"LightMapConfigs"}),":"]}),"\n",(0,a.jsxs)(i.ol,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"HighPrecision"})," (scale = 100):","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"alta qualit\xe0 visiva;"}),"\n",(0,a.jsx)(i.li,{children:"adatto per ambienti piccoli/medi."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"Fast"})," (scale = 5):","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"performance ottimale;"}),"\n",(0,a.jsx)(i.li,{children:"adatto per ambienti grandi."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.code,{children:"Default"})," (scale = 10):","\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsx)(i.li,{children:"bilanciamento qualit\xe0/performance;"}),"\n",(0,a.jsx)(i.li,{children:"configurazione standard."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(i.h2,{id:"motivazioni-per-la-scelta-di-squidlib",children:"Motivazioni per la scelta di SquidLib"}),"\n",(0,a.jsxs)(i.p,{children:["La libreria ",(0,a.jsx)(i.strong,{children:"SquidLib"})," \xe8 stata scelta per il calcolo del FOV per diverse ragioni:"]}),"\n",(0,a.jsxs)(i.ul,{children:["\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"basata su griglia"}),": opera nativamente su griglie 2D;"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"fisica semplificata"}),": fornisce un modello di visibilit\xe0 binario (visibile/non visibile) e un'attenuazione lineare;"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"performance"}),": \xe8 ottimizzata per calcoli rapidi su griglie;"]}),"\n",(0,a.jsxs)(i.li,{children:[(0,a.jsx)(i.strong,{children:"API minimale"}),": l'API \xe8 semplice e diretta (",(0,a.jsx)(i.code,{children:"FOV.reuseFOV(...)"}),"), facilitando l'integrazione."]}),"\n"]})]})}function p(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,a.jsx)(i,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,i,n)=>{n.d(i,{R:()=>s,x:()=>t});var l=n(6540);const a={},o=l.createContext(a);function s(e){const i=l.useContext(o);return l.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),l.createElement(o.Provider,{value:i},e.children)}}}]);